library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity ascon_controller is
    Port ( 
        clk, rst_n       : in STD_LOGIC;
        buffer_full      : in STD_LOGIC;
        btn_encrypt      : in STD_LOGIC;
        btn_decrypt      : in STD_LOGIC;
        perm_done        : in STD_LOGIC;
        tag_valid        : in STD_LOGIC; -- Input hasil perbandingan Tag (dari Datapath)
        
        -- Output Control Signals
        en_SI            : out STD_LOGIC;
        is_decrypt       : out STD_LOGIC;
        en_xor_lsb       : out STD_LOGIC;
        start_perm       : out STD_LOGIC;
        round_mode       : out STD_LOGIC;
        led_busy         : out STD_LOGIC;
        led_done         : out STD_LOGIC;
        status_error     : out STD_LOGIC;
        mux_sel          : out STD_LOGIC_VECTOR(2 downto 0)
    );
end ascon_controller;

architecture Behavioral of ascon_controller is
    type state_type is (
        ST_IDLE, ST_RX_WAIT, ST_BTN_WAIT, 
        ST_INIT_LOAD, ST_INIT_PERM_TRIG, ST_INIT_PERM_WAIT, ST_INIT_XOR_KEY,
        
        -- State AD (Associated Data) diaktifkan
        ST_AD_XOR, ST_AD_PERM_TRIG, ST_AD_PERM_WAIT, ST_DOM_SEP,
        
        ST_DATA_XOR, 
        ST_FINAL_XOR_KEY, ST_FINAL_PERM_TRIG, ST_FINAL_PERM_WAIT, 
        ST_CHECK_TAG, ST_DONE, ST_ERROR
    );
    
    signal state : state_type;
    signal r_is_decrypt : std_logic;
    
begin
    is_decrypt <= r_is_decrypt;

    process(clk, rst_n)
    begin
        if rst_n = '0' then
            state <= ST_IDLE; 
            r_is_decrypt <= '0';
            en_SI <= '0'; mux_sel <= "000"; en_xor_lsb <= '0'; 
            start_perm <= '0'; round_mode <= '0'; 
            led_busy <= '0'; led_done <= '0';
        elsif rising_edge(clk) then
            -- Default Pulse Values
            en_SI <= '0'; start_perm <= '0'; en_xor_lsb <= '0'; 

            case state is
                when ST_IDLE => 
                    state <= ST_RX_WAIT; 
                    led_done <= '0';
                    
                when ST_RX_WAIT => 
                    if buffer_full = '1' then state <= ST_BTN_WAIT; end if;
                    
                when ST_BTN_WAIT =>
                    if btn_encrypt = '1' then 
                        r_is_decrypt <= '0'; state <= ST_INIT_LOAD; led_busy <= '1';
                    elsif btn_decrypt = '1' then 
                        r_is_decrypt <= '1'; state <= ST_INIT_LOAD; led_busy <= '1'; 
                    end if;

                -- === 1. INITIALIZATION ===
                when ST_INIT_LOAD => 
                    mux_sel <= "000"; en_SI <= '1'; state <= ST_INIT_PERM_TRIG;
                
                when ST_INIT_PERM_TRIG => 
                    round_mode <= '0'; start_perm <= '1'; state <= ST_INIT_PERM_WAIT;
                    
                when ST_INIT_PERM_WAIT => 
                    round_mode <= '0';
                    if perm_done = '1' then 
                        mux_sel <= "001"; en_SI <= '1'; state <= ST_INIT_XOR_KEY; 
                    end if;

                when ST_INIT_XOR_KEY =>
                    mux_sel <= "101"; en_SI <= '1'; 
                    -- REVISI: Lanjut ke proses AD karena ada input AD 16 Byte
                    state <= ST_AD_XOR; 
                
                -- === 2. ASSOCIATED DATA (AD) ===
                when ST_AD_XOR => 
                    mux_sel <= "010"; -- XOR AD
                    en_SI <= '1'; 
                    state <= ST_AD_PERM_TRIG;
                
                when ST_AD_PERM_TRIG => 
                    round_mode <= '1'; -- 8 Ronde (Ascon-128a)
                    start_perm <= '1'; state <= ST_AD_PERM_WAIT;
                    
                when ST_AD_PERM_WAIT => 
                    round_mode <= '1';
                    if perm_done = '1' then 
                        mux_sel <= "001"; en_SI <= '1'; state <= ST_DOM_SEP; 
                    end if;
                
                -- === 3. DOMAIN SEPARATION ===
                when ST_DOM_SEP => 
                    en_xor_lsb <= '1'; state <= ST_DATA_XOR;

                -- === 4. DATA PROCESSING ===
                when ST_DATA_XOR => 
                    mux_sel <= "011"; en_SI <= '1'; 
                    state <= ST_FINAL_XOR_KEY; 

                -- === 5. FINALIZATION ===
                when ST_FINAL_XOR_KEY => 
                    mux_sel <= "100"; en_SI <= '1'; state <= ST_FINAL_PERM_TRIG;
                
                when ST_FINAL_PERM_TRIG => 
                    round_mode <= '0'; start_perm <= '1'; state <= ST_FINAL_PERM_WAIT;
                    
                when ST_FINAL_PERM_WAIT => 
                    round_mode <= '0';
                    if perm_done = '1' then 
                        mux_sel <= "001"; en_SI <= '1'; state <= ST_CHECK_TAG; 
                    end if;
                
                -- === 6. VERIFICATION & DECISION ===
                when ST_CHECK_TAG =>
                    if r_is_decrypt = '0' then
                        -- Mode ENCRYPT: Tidak perlu cek tag, langsung selesai
                        state <= ST_DONE;
                    else
                        -- Mode DECRYPT: Cek apakah Tag yang dihitung == Tag Input?
                        if tag_valid = '1' then
                            state <= ST_DONE;  -- Sukses
                        else
                            state <= ST_ERROR; -- Gagal
                        end if;
                    end if;

                when ST_DONE => 
                    led_busy <= '0'; led_done <= '1';
                    -- Diam sampai reset
                    
                when ST_ERROR => 
                    led_busy <= '0';
                    -- Diam di state error (Top level akan baca status_error)
                    
                when others => state <= ST_IDLE;
            end case;
        end if;
    end process;
    
    status_error <= '1' when state = ST_ERROR else '0';

end Behavioral;
