library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use work.ascon_pkg.ALL;

entity ascon_top is
    Port ( 
        -- --- CLOCK & RESET ---
        clk           : in  STD_LOGIC;
        rst_n         : in  STD_LOGIC;
        
        -- --- KOMUNIKASI SERIAL (UART) ---
        uart_rx_pin   : in  STD_LOGIC;
        uart_tx_pin   : out STD_LOGIC;
        
        -- --- TOMBOL KONTROL (Active Low) ---
        btn_encrypt   : in  STD_LOGIC;
        btn_decrypt   : in  STD_LOGIC;
        
        -- --- LAMPU INDIKATOR ---
        led_loading   : out STD_LOGIC; 
        led_process   : out STD_LOGIC; 
        led_ready     : out STD_LOGIC  
    );
end ascon_top;

architecture Behavioral of ascon_top is

    -- KONFIGURASI BAUD RATE
    -- Rumus: Clock Frequency / Baud Rate
    -- Contoh: 50.000.000 / 115200 = 434
    constant C_CLKS_PER_BIT : integer := 434; 

    -- Sinyal Data (Fixed 128-bit)
    signal w_rx_dv        : std_logic;
    signal w_rx_byte      : std_logic_vector(7 downto 0);
    
    signal w_key          : std_logic_vector(127 downto 0);
    signal w_nonce        : std_logic_vector(127 downto 0);
    signal w_ad           : std_logic_vector(127 downto 0);
    signal w_tag_in       : std_logic_vector(127 downto 0);
    signal w_data_in      : std_logic_vector(127 downto 0); 
    signal w_buffer_full  : std_logic;
    
    -- Sinyal Kontrol Internal
    signal w_en_si        : std_logic;
    signal w_mux_sel      : std_logic_vector(2 downto 0);
    signal w_is_decrypt   : std_logic;
    signal w_en_xor_lsb   : std_logic;
    signal w_start_perm   : std_logic;
    signal w_round_mode   : std_logic;
    signal w_perm_done    : std_logic;
    signal w_tag_valid    : std_logic;
    
    -- Sinyal Output dari Datapath
    signal w_out_data     : std_logic_vector(127 downto 0);
    signal w_out_tag      : std_logic_vector(127 downto 0);
    
    -- Status Controller
    signal w_ctrl_done    : std_logic; 
    signal w_ctrl_error   : std_logic;
    
    -- Register Hasil
    signal r_result_data : std_logic_vector(127 downto 0);
    signal r_result_tag  : std_logic_vector(127 downto 0);
    
    -- UART TX Variables
    type tx_state_type is (TX_IDLE, TX_LOAD_MSG, TX_LOAD_ERROR, TX_SENDING, TX_WAIT_BYTE, TX_DONE);
    signal tx_state       : tx_state_type := TX_IDLE;
    signal tx_byte_cnt    : integer range 0 to 63; 
    signal tx_data_buffer : std_logic_vector(255 downto 0);
    signal tx_total_bytes : integer range 0 to 64; 
    signal w_tx_start     : std_logic;
    signal w_tx_byte      : std_logic_vector(7 downto 0);
    signal w_tx_done_tick : std_logic;
    signal w_tx_busy      : std_logic;

    -- Pesan Error: "Tag Tidak Valid" (ASCII to Hex)
    constant MSG_ERROR_HEX : std_logic_vector(119 downto 0) := x"54616720546964616B2056616C6964";
    
    signal w_btn_encrypt_db : std_logic;
    signal w_btn_decrypt_db : std_logic;

begin

    -- 1. INPUT DEBOUNCERS
    -- Membalik logic tombol (active low -> active high internal)
    inst_db_enc : entity work.debouncer
    port map ( clk => clk, rst_n => rst_n, btn_in => not btn_encrypt, btn_out => w_btn_encrypt_db );
    
    inst_db_dec : entity work.debouncer
    port map ( clk => clk, rst_n => rst_n, btn_in => not btn_decrypt, btn_out => w_btn_decrypt_db );

    -- 2. UART RX (Updated Baud Rate)
    inst_uart_rx : entity work.uart_rx 
    generic map ( CLKS_PER_BIT => C_CLKS_PER_BIT )
    port map ( i_Clk => clk, i_Rst_n => rst_n, i_RX_Serial => uart_rx_pin, o_RX_DV => w_rx_dv, o_RX_Byte => w_rx_byte );

    -- 3. INPUT BUFFER
    inst_buffer : entity work.input_buffer 
    port map (
        clk => clk, rst_n => rst_n, rx_data => w_rx_byte, rx_valid => w_rx_dv,
        reg_key => w_key, reg_nonce => w_nonce, reg_ad => w_ad, 
        reg_data => w_data_in, 
        reg_tag_in => w_tag_in, buffer_full => w_buffer_full
    );
    led_loading <= not w_buffer_full; -- Nyala saat buffer belum penuh
    
    -- 4. DATAPATH
    inst_datapath : entity work.ascon_datapath 
    port map (
        clk => clk, rst_n => rst_n, en_SI => w_en_si, mux_sel => w_mux_sel, 
        is_decrypt => w_is_decrypt, en_xor_lsb => w_en_xor_lsb,
        start_perm => w_start_perm, round_mode => w_round_mode, perm_done => w_perm_done, 
        in_key => w_key, in_nonce => w_nonce, in_ad => w_ad, 
        in_data => w_data_in, in_tag => w_tag_in, 
        out_data => w_out_data, out_tag => w_out_tag, 
        tag_valid => w_tag_valid
    );
    
    -- 5. UART TX (Updated Baud Rate)
    inst_uart_tx : entity work.uart_tx 
    generic map ( CLKS_PER_BIT => C_CLKS_PER_BIT )
    port map ( i_Clk => clk, i_Rst_n => rst_n, i_TX_DV => w_tx_start, i_TX_Byte => w_tx_byte, 
               o_TX_Active => w_tx_busy, o_TX_Serial => uart_tx_pin, o_TX_Done => w_tx_done_tick );

    -- 6. CONTROLLER
    inst_controller : entity work.ascon_controller
    port map (
        clk => clk, rst_n => rst_n, buffer_full => w_buffer_full, 
        btn_encrypt => w_btn_encrypt_db, btn_decrypt => w_btn_decrypt_db, 
        perm_done => w_perm_done, tag_valid => w_tag_valid, 
        en_SI => w_en_si, mux_sel => w_mux_sel, is_decrypt => w_is_decrypt,
        en_xor_lsb => w_en_xor_lsb, start_perm => w_start_perm, round_mode => w_round_mode,
        led_busy => led_process, led_done => w_ctrl_done, status_error => w_ctrl_error 
    );

    -- 7. PENYIMPAN HASIL
    process(clk, rst_n)
    begin
        if rst_n = '0' then
            r_result_data <= (others => '0');
            r_result_tag  <= (others => '0');
        elsif rising_edge(clk) then
            -- Simpan Data (Ciphertext atau Plaintext)
            if w_en_si = '1' and w_mux_sel = "011" then
                r_result_data <= w_out_data;
            end if;
            
            -- Simpan Tag Baru (selalu simpan saat selesai, untuk dikirim jika mode encrypt)
            if w_ctrl_done = '1' then 
                r_result_tag <= w_out_tag;
            end if;
        end if;
    end process;

    -- =========================================================================
    -- 8. UART SERIALIZER (LOGIKA PENGIRIMAN SESUAI REQUEST)
    -- =========================================================================
    process(clk, rst_n)
    begin
        if rst_n = '0' then
            tx_state       <= TX_IDLE;
            tx_byte_cnt    <= 0;
            w_tx_start     <= '0';
            tx_data_buffer <= (others => '0');
            led_ready      <= '0';
            
        elsif rising_edge(clk) then
            w_tx_start <= '0';
            
            case tx_state is
                
                when TX_IDLE =>
                    tx_byte_cnt <= 0;
                    led_ready   <= '0';
                    
                    -- KASUS 1: PROSES SUKSES
                    if w_ctrl_done = '1' then
                        
                        -- Slot Atas: Hasil Data (CT atau PT)
                        tx_data_buffer(255 downto 128) <= r_result_data;
                        
                        if w_is_decrypt = '0' then
                            -- === MODE ENCRYPT ===
                            -- Kirim: Ciphertext (16 Byte) + Tag Baru (16 Byte) = 32 Byte
                            -- Gunakan r_result_tag yang sudah disimpan (stable)
                            tx_data_buffer(127 downto 0) <= r_result_tag;
                            tx_total_bytes <= 32;
                        else
                            -- === MODE DECRYPT (VALID) ===
                            -- Kirim: Plaintext (16 Byte) SAJA
                            tx_total_bytes <= 16;
                        end if;
                        
                        tx_state <= TX_LOAD_MSG;
                        
                    -- KASUS 2: PROSES GAGAL (Tag Invalid saat Decrypt)
                    elsif w_ctrl_error = '1' then
                        -- Kirim Pesan Error: "Tag Tidak Valid"
                        tx_data_buffer(255 downto 136) <= MSG_ERROR_HEX;
                        tx_total_bytes <= 15; -- Panjang string
                        tx_state       <= TX_LOAD_ERROR;
                    end if;

                when TX_LOAD_MSG | TX_LOAD_ERROR =>
                    led_ready <= '1';
                    tx_state  <= TX_SENDING;

                when TX_SENDING =>
                    -- Mengambil byte dari MSB buffer
                    w_tx_byte  <= tx_data_buffer(255 - (tx_byte_cnt * 8) downto 255 - (tx_byte_cnt * 8) - 7);
                    w_tx_start <= '1';
                    tx_state   <= TX_WAIT_BYTE;

                when TX_WAIT_BYTE =>
                    if w_tx_done_tick = '1' then
                        if tx_byte_cnt = (tx_total_bytes - 1) then
                            tx_state <= TX_DONE;
                        else
                            tx_byte_cnt <= tx_byte_cnt + 1;
                            tx_state    <= TX_SENDING;
                        end if;
                    end if;
                    
                when TX_DONE =>
                    led_ready <= '1';
                    -- Diam di sini sampai di-reset manual oleh user
                
                when others =>
                    tx_state <= TX_IDLE;
            end case;
        end if;
    end process;

end Behavioral;
