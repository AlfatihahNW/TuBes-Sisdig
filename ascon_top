library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use work.ascon_pkg.ALL;

entity ascon_top is
    Port ( 
        -- --- CLOCK & RESET ---
        clk           : in  STD_LOGIC;
        rst_n         : in  STD_LOGIC;
        
        -- --- KOMUNIKASI SERIAL (UART) ---
        uart_rx_pin   : in  STD_LOGIC;
        uart_tx_pin   : out STD_LOGIC;
        
        -- --- TOMBOL KONTROL (Active Low) ---
        btn_encrypt   : in  STD_LOGIC;
        btn_decrypt   : in  STD_LOGIC;
        
        -- --- LAMPU INDIKATOR (Active Low) ---
        led_loading   : out STD_LOGIC; 
        led_process   : out STD_LOGIC; -- INI BERFUNGSI SEBAGAI LED DONE
        led_ready     : out STD_LOGIC  
    );
end ascon_top;

architecture Behavioral of ascon_top is

    -- Sinyal Data
    signal w_rx_dv        : std_logic;
    signal w_rx_byte      : std_logic_vector(7 downto 0);
    signal w_key          : std_logic_vector(127 downto 0);
    signal w_nonce        : std_logic_vector(127 downto 0);
    signal w_ad           : std_logic_vector(127 downto 0);
    signal w_tag_in       : std_logic_vector(127 downto 0);
    signal w_data_in      : std_logic_vector(127 downto 0); 
    signal w_buffer_full  : std_logic;

    -- Sinyal Kontrol Internal
    signal w_en_si        : std_logic;
    signal w_mux_sel      : std_logic_vector(2 downto 0);
    signal w_is_decrypt   : std_logic;
    signal w_en_xor_lsb   : std_logic;
    signal w_start_perm   : std_logic;
    signal w_round_mode   : std_logic;
    signal w_perm_done    : std_logic;
    signal w_tag_valid    : std_logic;

    -- Sinyal Output dari Datapath
    signal w_out_data     : std_logic_vector(127 downto 0);
    signal w_out_tag      : std_logic_vector(127 downto 0);

    -- Status Controller
    signal w_ctrl_done    : std_logic; 
    signal w_ctrl_error   : std_logic;
    -- Note: led_busy dari controller tidak dipakai langsung ke pin luar
    signal w_ctrl_busy    : std_logic; 

    -- Register Hasil
    signal r_result_data  : std_logic_vector(127 downto 0);
    signal r_result_tag   : std_logic_vector(127 downto 0);
    
    -- UART TX Variables
    type tx_state_type is (TX_IDLE, TX_LOAD_MSG, TX_LOAD_ERROR, TX_SENDING, TX_WAIT_BYTE, TX_DONE);
    signal tx_state       : tx_state_type := TX_IDLE;
    signal tx_byte_cnt    : integer range 0 to 63; 
    signal tx_data_buffer : std_logic_vector(255 downto 0);
    signal tx_total_bytes : integer range 0 to 64; 
    signal w_tx_start     : std_logic;
    signal w_tx_byte      : std_logic_vector(7 downto 0);
    signal w_tx_done_tick : std_logic;
    signal w_tx_busy      : std_logic;

    constant MSG_ERROR_HEX : std_logic_vector(119 downto 0) := x"54616720546964616B2056616C6964"; 
    -- "Tag Tidak Valid"
    
    signal w_btn_encrypt_db : std_logic;
    signal w_btn_decrypt_db : std_logic;

    -- Flag untuk Logika LED Baru
    signal r_reception_started : std_logic := '0';

begin

    -- 1. INPUT DEBOUNCERS
    inst_db_enc : entity work.debouncer
    port map ( clk => clk, rst_n => rst_n, btn_in => not btn_encrypt, btn_out => w_btn_encrypt_db );
    
    inst_db_dec : entity work.debouncer
    port map ( clk => clk, rst_n => rst_n, btn_in => not btn_decrypt, btn_out => w_btn_decrypt_db );

    -- 2. UART RX
    inst_uart_rx : entity work.uart_rx 
    port map ( i_Clk => clk, i_Rst_n => rst_n, i_RX_Serial => uart_rx_pin, o_RX_DV => w_rx_dv, o_RX_Byte => w_rx_byte );

    -- 3. INPUT BUFFER
    inst_buffer : entity work.input_buffer 
    port map (
        clk => clk, rst_n => rst_n, rx_data => w_rx_byte, rx_valid => w_rx_dv,
        reg_key => w_key, reg_nonce => w_nonce, reg_ad => w_ad, 
        reg_data => w_data_in, 
        reg_tag_in => w_tag_in, buffer_full => w_buffer_full
    );
    
    -- 4. DATAPATH
    inst_datapath : entity work.ascon_datapath 
    port map (
        clk => clk, rst_n => rst_n, en_SI => w_en_si, mux_sel => w_mux_sel, is_decrypt => w_is_decrypt, en_xor_lsb => w_en_xor_lsb,
        start_perm => w_start_perm, round_mode => w_round_mode, perm_done => w_perm_done, in_key => w_key, in_nonce => w_nonce,
        in_ad => w_ad, in_data => w_data_in, in_tag => w_tag_in, 
        out_data => w_out_data, out_tag => w_out_tag, tag_valid => w_tag_valid
    );
    
    -- 5. UART TX
    inst_uart_tx : entity work.uart_tx 
    port map ( i_Clk => clk, i_Rst_n => rst_n, i_TX_DV => w_tx_start, i_TX_Byte => w_tx_byte, o_TX_Active => w_tx_busy, o_TX_Serial => uart_tx_pin, o_TX_Done => w_tx_done_tick );

    -- 6. CONTROLLER
    inst_controller : entity work.ascon_controller
    port map (
        clk => clk, rst_n => rst_n, buffer_full => w_buffer_full, btn_encrypt => w_btn_encrypt_db, btn_decrypt => w_btn_decrypt_db, 
        perm_done => w_perm_done, tag_valid => w_tag_valid, en_SI => w_en_si, mux_sel => w_mux_sel, is_decrypt => w_is_decrypt,
        en_xor_lsb => w_en_xor_lsb, start_perm => w_start_perm, round_mode => w_round_mode,
        led_busy => w_ctrl_busy, led_done => w_ctrl_done, status_error => w_ctrl_error 
    );

    -- 7. PENYIMPAN HASIL (DATA + TAG)
    process(clk, rst_n)
    begin
        if rst_n = '0' then
            r_result_data <= (others => '0');
            r_result_tag  <= (others => '0');
        elsif rising_edge(clk) then
            -- Simpan Data (Ciphertext / Plaintext) 
            if w_en_si = '1' and w_mux_sel = "011" then
                r_result_data <= w_out_data;
            end if;
            
            -- Simpan Tag (Saat controller selesai/error)
            if w_ctrl_done = '1' or w_ctrl_error = '1' then 
                r_result_tag <= w_out_tag;
            end if;
        end if;
    end process;

    -- =========================================================================
    -- 8. MANAJEMEN LED (LOGIKA BARU - ACTIVE LOW)
    -- =========================================================================
    -- led_ready   : Nyala saat reset, Mati saat byte pertama masuk.
    -- led_loading : Nyala saat byte pertama masuk, Mati saat buffer penuh.
    -- led_process : (Fungsi DONE) Mati saat awal, Nyala saat TX UART selesai.
    
    process(clk, rst_n)
    begin
        if rst_n = '0' then
            r_reception_started <= '0';
            led_ready           <= '0'; -- ON (Active Low)
            led_loading         <= '1'; -- OFF (Active Low)
        elsif rising_edge(clk) then
            
            -- Deteksi penerimaan byte pertama
            if w_rx_dv = '1' then
                r_reception_started <= '1';
            end if;
            
            -- LOGIKA LED READY
            if r_reception_started = '0' then
                led_ready <= '0'; -- Nyala (Belum ada data masuk)
            else
                led_ready <= '1'; -- Mati (Sudah ada data masuk)
            end if;
            
            -- LOGIKA LED LOADING
            -- Nyala jika sudah mulai terima data TAPI buffer belum penuh
            if r_reception_started = '1' and w_buffer_full = '0' then
                led_loading <= '0'; -- Nyala
            else
                led_loading <= '1'; -- Mati
            end if;
            
        end if;
    end process;

    -- =========================================================================
    -- 9. UART SERIALIZER & LED DONE (ACTIVE LOW)
    -- =========================================================================
    process(clk, rst_n)
    begin
        if rst_n = '0' then
            tx_state        <= TX_IDLE;
            tx_byte_cnt     <= 0;
            w_tx_start      <= '0';
            tx_data_buffer  <= (others => '0');
            led_process     <= '1'; -- LED DONE default OFF (Active Low)
        elsif rising_edge(clk) then
            w_tx_start <= '0';
            
            case tx_state is
                
                when TX_IDLE =>
                    tx_byte_cnt <= 0;
                    led_process <= '1'; -- Pastikan LED Done mati saat Idle/Reset
                    
                    -- KASUS 1: SUKSES (Encrypt atau Valid Decrypt)
                    if w_ctrl_done = '1' then
                        -- Ambil Data Hasil
                        tx_data_buffer(255 downto 128) <= r_result_data;

                        if w_is_decrypt = '0' then
                            -- === MODE ENCRYPT ===
                            -- Kirim CT + Tag
                            -- Gunakan w_out_tag langsung agar data fresh
                            tx_data_buffer(127 downto 0) <= w_out_tag;
                            tx_total_bytes <= 32; 
                        else
                            -- === MODE DECRYPT ===
                            -- Kirim Plaintext saja (Tag valid, tidak dikirim balik)
                            tx_total_bytes <= 16;
                        end if;
                        
                        tx_state <= TX_LOAD_MSG;
                        
                    -- KASUS 2: ERROR (Tag Invalid saat Decrypt)
                    elsif w_ctrl_error = '1' then
                        -- Isi buffer dengan pesan "Tag Tidak Valid"
                        tx_data_buffer(255 downto 136) <= MSG_ERROR_HEX;
                        tx_data_buffer(135 downto 0)   <= (others => '0');
                        
                        tx_total_bytes <= 15;
                        tx_state       <= TX_LOAD_ERROR;
                    end if;

                when TX_LOAD_MSG | TX_LOAD_ERROR =>
                    tx_state  <= TX_SENDING;

                when TX_SENDING =>
                    -- Mengirim byte per byte (MSB First)
                    w_tx_byte  <= tx_data_buffer(255 - (tx_byte_cnt * 8) downto 255 - (tx_byte_cnt * 8) - 7);
                    w_tx_start <= '1';
                    tx_state   <= TX_WAIT_BYTE;

                when TX_WAIT_BYTE =>
                    if w_tx_done_tick = '1' then
                        if tx_byte_cnt = (tx_total_bytes - 1) then
                            tx_state <= TX_DONE;
                        else
                            tx_byte_cnt <= tx_byte_cnt + 1;
                            tx_state    <= TX_SENDING;
                        end if;
                    end if;
                
                when TX_DONE =>
                    -- PENGIRIMAN SELESAI
                    led_process <= '0'; -- Nyalakan LED Done (Active Low)
                    -- Tetap di state ini sampai reset
                
                when others =>
                    tx_state <= TX_IDLE;
            end case;
        end if;
    end process;

end Behavioral;
