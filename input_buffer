library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity input_buffer is
    Port ( 
        clk, rst_n, rx_valid : in STD_LOGIC;
        rx_data : in STD_LOGIC_VECTOR (7 downto 0);

        reg_key      : out STD_LOGIC_VECTOR (127 downto 0);
        reg_nonce    : out STD_LOGIC_VECTOR (127 downto 0);
        reg_ad       : out STD_LOGIC_VECTOR (127 downto 0);
        reg_data     : out STD_LOGIC_VECTOR (127 downto 0); 
        reg_tag_in   : out STD_LOGIC_VECTOR (127 downto 0);
        buffer_full  : out STD_LOGIC
    );
end input_buffer;

architecture Behavioral of input_buffer is
    type mem_type is array (0 to 127) of std_logic_vector(7 downto 0);
    signal r_mem : mem_type := (others => (others => '0'));
    
    signal r_byte_cnt : integer range 0 to 127 := 0;
    
    -- TIMER DIPERBESAR: 2.500.000 clock = 50ms @ 50MHz
    -- Wajib untuk menampung jeda 9600 baud (1 byte ~1ms)
    signal r_timer : integer range 0 to 2500000 := 0;
    signal r_data_done : std_logic := '0';
begin

    process(clk, rst_n)
    begin
        if rst_n = '0' then
            r_byte_cnt <= 0;
            r_timer <= 0; 
            r_data_done <= '0';
            r_mem <= (others => (others => '0'));
        elsif rising_edge(clk) then
            if rx_valid = '1' then
                -- Reset timer setiap ada byte masuk
                r_timer <= 0; 
                r_data_done <= '0';
                
                if r_byte_cnt < 80 then 
                    r_mem(r_byte_cnt) <= rx_data;
                    r_byte_cnt <= r_byte_cnt + 1; 
                end if;
            else
                -- Timer Logic
                if r_byte_cnt > 0 and r_data_done = '0' then
                    if r_timer < 2500000 then 
                        r_timer <= r_timer + 1;
                    else 
                        -- Timeout tercapai (anggap data selesai)
                        r_data_done <= '1';
                    end if;
                end if;
            end if;
        end if;
    end process;

    buffer_full <= r_data_done;

    -- MAPPING DATA (Concat Manual Big Endian)
    reg_key <= r_mem(0) & r_mem(1) & r_mem(2) & r_mem(3) & r_mem(4) & r_mem(5) & r_mem(6) & r_mem(7) &
               r_mem(8) & r_mem(9) & r_mem(10) & r_mem(11) & r_mem(12) & r_mem(13) & r_mem(14) & r_mem(15);

    reg_nonce <= r_mem(16) & r_mem(17) & r_mem(18) & r_mem(19) & r_mem(20) & r_mem(21) & r_mem(22) & r_mem(23) &
                 r_mem(24) & r_mem(25) & r_mem(26) & r_mem(27) & r_mem(28) & r_mem(29) & r_mem(30) & r_mem(31);
                 
    reg_ad <= r_mem(32) & r_mem(33) & r_mem(34) & r_mem(35) & r_mem(36) & r_mem(37) & r_mem(38) & r_mem(39) &
              r_mem(40) & r_mem(41) & r_mem(42) & r_mem(43) & r_mem(44) & r_mem(45) & r_mem(46) & r_mem(47);
              
    reg_data <= r_mem(48) & r_mem(49) & r_mem(50) & r_mem(51) & r_mem(52) & r_mem(53) & r_mem(54) & r_mem(55) &
                r_mem(56) & r_mem(57) & r_mem(58) & r_mem(59) & r_mem(60) & r_mem(61) & r_mem(62) & r_mem(63);
                
    reg_tag_in <= r_mem(64) & r_mem(65) & r_mem(66) & r_mem(67) & r_mem(68) & r_mem(69) & r_mem(70) & r_mem(71) &
                  r_mem(72) & r_mem(73) & r_mem(74) & r_mem(75) & r_mem(76) & r_mem(77) & r_mem(78) & r_mem(79);

end Behavioral;
